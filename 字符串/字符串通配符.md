### 字符串通配

* 递归方法
```C++
#include <iostream>
using namespace std;
bool match(int i,int j);
string rg;
string str;
int main() {
    cin>>rg>>str;
    if(match(0,0))
        cout<<"true";
    else
        cout<<"false";
}
bool match(int i,int j)
{
    if(i==rg.size()&&j==str.size())
        return true;
    else{
        if(i==rg.size()||j==str.size())
            return false;
        //i和j接下来都在范围内的情况
        if(rg[i]=='?')
        {
            if(isalnum(str[j]))
                return match(++i,++j);
            else
                return false;
        }else{
            if(rg[i]=='*')
            {
               while(i<rg.size()&&rg[i]=='*')//找到第一个不是'*'的字符，如果找不到，就是匹配成功
               {
                   ++i;
               }
               if(i==rg.size())//说明从头到尾都是*
               {
                   //接下来需要判断str中有没有类似'#'的字符
                   while(j<str.size())
                   {
                       if(!isalnum(str[j]))
                            return false;
                        ++j;
                   }
                   return true;
               }else{//在rg中*后面找到了不是*的字符
                    bool flag=false;
                    while(j<str.size())
                    {
                        flag|=match(i,j);
                        ++j;
                    }
                    return flag;   
               }
            }else{
                if(isalpha(rg[i])&&isalpha(str[i]))//如果二者都是字母
                {
                    if(tolower(rg[i])==tolower(str[j]))//都变成小写进行比较
                        return match(++i,++j);
                    else
                        return false;
                }else{//否则直接比较
                    if(rg[i]==str[j])
                        return match(++i,++j);//比较正确，开始匹配下一个字符
                    else
                        return false;
                }
            }
        }
            
    }
}
```

* 动态规划
