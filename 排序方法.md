### 选择排序
1. 简答选择排序
2. 树形选择排序
3. 堆排序
* 时间复杂度: $O\left( n\log n\right) $
* 空间复杂度: $O\left( 1\right)$
* 不稳定排序
* 特点：  
    * 时间主要耗费在建初始堆和调整堆
    * 适合n比较大的文件内部排序
```C++
//对size为n+1的vector中位置1-n的数组进行堆排序
//如果进行非递减排序则建立大根堆，进行递减排序则进行小根堆

void heapSort(vector<int> &v)
{
    int n=v.size()-1;//0位置不用，符合完全二叉树堆位置对应关系
    for(int i=n/2;i>=1;--i)//开始对完全二叉树第一个非叶子节点进行堆调整
    {
        heapadjust(v,i,n);
    }//完成初始建堆
    for(int i=n;i>1;i--)//在此基础上只需要n-1次调整即可完成排序
    {
        swap(v[1],v[i]);//将堆顶记录和当前还未经排序的最好一个元素记录进行替换
        heapadjust(v,1,i-1);//堆调整,将vector[1~i-1]调整成一个新堆
    }
}
void heapadjust(vector<int> &v,int cur,int tail)
{
    int val=v[cur];
    for(int k=2*cur;k<=tail;k*=2)
    {
        if(k<tail&&v[k]>v[k+1])//k指向cur左右子树较小值，k<tail是确保cur有右子树
            ++k;
        if(val<v[k])//没有必要继续调整，已经是堆了
            break;
        else{
            v[cur]=v[k];
            cur=k;//重新以k==cur为根节点调整树堆
        }
    }
    v[cur]=val;
}
```
### 交换排序
1. 冒泡排序
* 时间复杂度: $O\left( n^{2}\right)$
* 空间复杂度: $O\left( 1\right)$
* 稳定排序
```C++ 
void BubbleSort(vector<int> &v)
{
    for(int i=1;i<v.size();i++)//只进行n-1趟排序,第i趟将最小值或者最大值放到v[v.size-i]处
    {
        for(int j=0;j<v.size()-i;j++)
        {
            if(v[j]>v[j+1])
                swap(v[j],v[j+1]);//交换
        }
    }
}
```
2. 快速排序

### 插入排序
1. 直接插入排序
* 时间复杂度: $O\left( n^{2}\right)$
* 空间复杂度: $O\left( 1\right)$
* 稳定排序
* 特点：  
    * 简单易实现
    * 当记录基本有序时或者n比较小时最佳
```C++
void InsertSort(vector<int> &v)//非递减直接插入排序
{
    //对从i=1到i=v.size()-1的元素，插入到i位置之前的有序队列里
    for(int i=1;i<=v.size()-1;i++)//v.size()个元素,v.size()-1趟排序
    {
        int value=v[i];
        int j;
        for(j=i-1;j>=0;j--)
        {
            if(value>=v[j])//不用继续比较，找到了插入位置了,退出底层for循环
            {
                break;
            }    
            else{
                v[j+1]=v[j];//后移
            }
        }
        v[j+1]=value;
    }
}
```
2. 折半插入排序
3. 2-路插入排序
4. 希尔排序

### 归并排序

### 基数排序