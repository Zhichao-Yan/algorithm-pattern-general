1. 堆排序
* 时间复杂度: $O\left( n\log n\right) $
* 空间复杂度: $O\left( 1\right)$
```C++
//对size为n+1的vector中位置1-n的数组进行堆排序
//如果进行非递减排序则建立大根堆，进行递减排序则进行小根堆

void heapSort(vector<int> &v)
{
    int n=v.size()-1;//0位置不用，符合完全二叉树堆位置对应关系
    for(int i=n/2;i>=1;--i)//开始对完全二叉树第一个非叶子节点进行堆调整
    {
        heapadjust(v,i,n);
    }//完成初始建堆
    for(int i=n;i>1;i--)//在此基础上只需要n-1次调整即可完成排序
    {
        swap(v[1],v[i]);//将堆顶记录和当前还未经排序的最好一个元素记录进行替换
        heapadjust(v,1,i-1);//堆调整,将vector[1~i-1]调整成一个新堆
    }
}
void heapadjust(vector<int> &v,int cur,int tail)
{
    int val=v[cur];
    for(int k=2*cur;k<=tail;k*=2)
    {
        if(k<tail&&v[k]>v[k+1])//k指向cur左右子树较小值，k<tail是确保cur有右子树
            ++k;
        if(val<v[k])//没有必要继续调整，已经是堆了
            break;
        else{
            v[cur]=v[k];
            cur=k;//重新以k==cur为根节点调整树堆
        }
    }
    v[cur]=val;
}
```
2. 冒泡排序